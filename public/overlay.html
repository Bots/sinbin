<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>SinBin Overlay</title>
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
            rel="stylesheet"
        />
        <style>
            :root {
                /* Default theme colors */
                --primary-color: #6366f1;
                --secondary-color: #f472b6;

                /* Element colors with alpha support */
                --background-color: rgba(0, 0, 0, 0.8);
                --bin-color: #ffffff;
                --counter-color: #000000;
                --status-color: #10b981;
                --transcript-color: #ffffff;

                /* Alpha values */
                --background-alpha: 0.8;
                --bin-alpha: 1;
                --counter-alpha: 1;
                --status-alpha: 1;
                --transcript-alpha: 0.9;

                /* Layout settings */
                --layout-direction: column;
                --transcript-position: after;
                --overlay-gap: 20px;
                --bin-size: 80px;
                --status-size: 12px;
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Inter', -apple-system, BlinkMacSystemFont,
                    'Segoe UI', Roboto, sans-serif;
                overflow: hidden;
                background: transparent;
                height: 100vh;
                width: 100vw;
            }

            .overlay-container {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: flex;
                flex-direction: var(--layout-direction);
                align-items: center;
                justify-content: center;
                gap: var(--overlay-gap);
                padding: 20px;
                background: var(--background-color);
                transition: all 0.3s ease;
            }

            .overlay-container > * {
                flex-shrink: 0;
            }

            .overlay-container.no-background {
                background: transparent;
            }

            .overlay-container.horizontal {
                --layout-direction: row;
                --overlay-gap: 30px;
            }

            .status-indicator {
                width: var(--status-size);
                height: var(--status-size);
                border-radius: 50%;
                background: var(--status-color);
                opacity: var(--status-alpha);
                transition: all 0.3s ease;
                box-shadow: 0 0 10px rgba(var(--status-color), 0.5);
                order: 2;
                align-self: center;
                flex-shrink: 0;
                min-width: var(--status-size);
                min-height: var(--status-size);
            }

            .status-indicator.hidden {
                display: none;
            }

            .trash-bin-container {
                position: relative;
                display: flex;
                align-items: center;
                justify-content: center;
                order: 1;
            }

            .trash-bin {
                width: var(--bin-size);
                height: var(--bin-size);
                color: var(--bin-color);
                opacity: var(--bin-alpha);
                filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
                transition: all 0.3s ease;
            }

            .counter {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: clamp(16px, calc(var(--bin-size) * 0.3), 60px);
                font-weight: 700;
                color: var(--counter-color);
                opacity: var(--counter-alpha);
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                transition: all 0.3s ease;
            }

            .transcript-container {
                width: 400px;
                max-width: min(60vw, 400px);
                order: 3;
                display: flex;
                align-items: center;
                justify-content: center;
                flex-shrink: 0;
            }

            .transcript-container.hidden {
                display: none;
            }

            .transcript-container.above {
                order: 0;
            }

            .status-indicator.transcript-above {
                order: 0.5;
            }

            .transcript-wrapper {
                overflow: hidden;
                width: 100%;
                height: 24px;
                display: flex;
                justify-content: center;
                align-items: center;
                position: relative;
            }

            .transcript-text {
                color: var(--transcript-color);
                opacity: var(--transcript-alpha);
                font-size: 16px;
                font-weight: 500;
                text-align: center;
                white-space: nowrap;
                transition: all 0.3s ease;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
                position: absolute;
                width: max-content;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
            }

            /* Position offscreen immediately when preparing to scroll to avoid a centered flash */
            .transcript-text.scroll-prep {
                left: 100% !important;
                transform: translate(0%, -50%) !important;
                transition: none !important;
            }

            /* Single pass scrolling animation for long text */
            .transcript-text.scrolling {
                animation: slide-right-to-left 8s linear forwards;
            }

            @keyframes slide-right-to-left {
                0% {
                    transform: translate(100%, -50%);
                }
                10% {
                    transform: translate(100%, -50%);
                }
                90% {
                    transform: translate(-200%, -50%);
                }
                100% {
                    transform: translate(-200%, -50%);
                }
            }

            /* Bin animation states */
            .trash-bin-container.shaking {
                animation: shake 0.6s ease-in-out;
            }

            .trash-bin-container.lid-tip {
                animation: lidTip 0.8s ease-in-out;
            }

            /* Bin shake animation */
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                10% { transform: translateX(-5px) rotate(-1deg); }
                20% { transform: translateX(5px) rotate(1deg); }
                30% { transform: translateX(-5px) rotate(-1deg); }
                40% { transform: translateX(5px) rotate(1deg); }
                50% { transform: translateX(-3px) rotate(-0.5deg); }
                60% { transform: translateX(3px) rotate(0.5deg); }
                70% { transform: translateX(-2px) rotate(-0.3deg); }
                80% { transform: translateX(2px) rotate(0.3deg); }
                90% { transform: translateX(-1px) rotate(-0.1deg); }
            }

            /* Lid tip animation */
            @keyframes lidTip {
                0% { transform: rotate(0deg); }
                15% { transform: rotate(-3deg) translateY(-2px); }
                30% { transform: rotate(-5deg) translateY(-4px); }
                45% { transform: rotate(-3deg) translateY(-2px); }
                60% { transform: rotate(2deg) translateY(-1px); }
                75% { transform: rotate(-1deg) translateY(-0.5px); }
                90% { transform: rotate(0.5deg); }
                100% { transform: rotate(0deg); }
            }

            /* Threshold-based color changes */
            .trash-bin.threshold-warning {
                color: var(--warning-color, #f59e0b);
                transition: color 0.3s ease;
            }

            .trash-bin.threshold-danger {
                color: var(--danger-color, #ef4444);
                transition: color 0.3s ease;
            }

            .counter.threshold-warning {
                color: var(--warning-color, #f59e0b);
                transition: color 0.3s ease;
            }

            .counter.threshold-danger {
                color: var(--danger-color, #ef4444);
                transition: color 0.3s ease;
            }

            /* Pulsing effect for danger threshold */
            .trash-bin-container.threshold-danger {
                animation: pulse 2s infinite;
            }

            @keyframes pulse {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.05); }
            }

            /* Responsive adjustments */
            @media (max-width: 600px) {
                .overlay-container {
                    padding: 15px;
                    --overlay-gap: 15px;
                    --bin-size: 60px;
                    --status-size: 10px;
                }

                .transcript-text {
                    font-size: 14px;
                }
            }
        </style>
    </head>
    <body>
        <div class="overlay-container" id="overlayContainer">
            <!-- Main trash bin icon with counter overlay -->
            <div class="trash-bin-container">
                <svg
                    class="trash-bin"
                    viewBox="0 0 100 100"
                    xmlns="http://www.w3.org/2000/svg"
                >
                    <!-- SVG trash bin with gradient fill -->
                    <defs>
                        <linearGradient
                            id="binGradient"
                            x1="0%"
                            y1="0%"
                            x2="0%"
                            y2="100%"
                        >
                            <stop
                                offset="0%"
                                style="
                                    stop-color: currentColor;
                                    stop-opacity: 1;
                                "
                            />
                            <stop
                                offset="100%"
                                style="
                                    stop-color: currentColor;
                                    stop-opacity: 0.8;
                                "
                            />
                        </linearGradient>
                    </defs>

                    <!-- Main container body -->
                    <rect
                        x="20"
                        y="35"
                        width="60"
                        height="50"
                        rx="8"
                        fill="url(#binGradient)"
                        stroke="currentColor"
                        stroke-width="2"
                    />

                    <!-- Container lid -->
                    <rect
                        x="15"
                        y="25"
                        width="70"
                        height="8"
                        rx="4"
                        fill="currentColor"
                    />

                    <!-- Lid handle -->
                    <rect
                        x="40"
                        y="15"
                        width="20"
                        height="6"
                        rx="3"
                        fill="currentColor"
                    />

                    <!-- Decorative vertical lines -->
                    <line
                        x1="35"
                        y1="45"
                        x2="35"
                        y2="70"
                        stroke="currentColor"
                        stroke-width="2"
                        opacity="0.3"
                    />
                    <line
                        x1="50"
                        y1="45"
                        x2="50"
                        y2="70"
                        stroke="currentColor"
                        stroke-width="2"
                        opacity="0.3"
                    />
                    <line
                        x1="65"
                        y1="45"
                        x2="65"
                        y2="70"
                        stroke="currentColor"
                        stroke-width="2"
                        opacity="0.3"
                    />
                </svg>

                <div class="counter" id="counter">0</div>
            </div>

            <!-- Status indicator -->
            <div class="status-indicator" id="statusIndicator"></div>

            <!-- Live transcription display -->
            <div class="transcript-container" id="transcriptContainer">
                <div class="transcript-wrapper">
                    <div class="transcript-text" id="transcriptText">
                        Listening for audio...
                    </div>
                </div>
            </div>
        </div>

        <script src="/socket.io/socket.io.js"></script>
        <script>
            class MinimalOverlay {
                constructor() {
                    this.socket = io()

                    // Default configuration state
                    this.config = {
                        layout: 'vertical',
                        transcriptPosition: 'below',
                        showBackground: true,
                        showStatus: true,
                        showTranscript: true,
                    }

                    // Cache DOM elements for better performance
                    this.elements = {
                        container: document.getElementById('overlayContainer'),
                        status: document.getElementById('statusIndicator'),
                        counter: document.getElementById('counter'),
                        transcript: document.getElementById('transcriptText'),
                        transcriptContainer: document.getElementById(
                            'transcriptContainer'
                        ),
                    }

                    this.setupSocketEvents()
                    this.applyDefaultTheme()
                    this.loadSavedSettings()
                }

                setupSocketEvents() {
                    // Handle real-time connection status updates
                    this.socket.on('connect', () => {
                        this.updateStatus('connected')
                        // Automatically start listening when connected
                        this.socket.emit('startListening')
                    })
                    this.socket.on('disconnect', () =>
                        this.updateStatus('disconnected')
                    )

                    // Update counter display when profanity is detected
                    this.socket.on('countUpdate', (count) =>
                        this.updateCounter(count)
                    )

                    // Apply theme changes from control panel
                    this.socket.on('themeUpdate', (theme) =>
                        this.updateTheme(theme)
                    )

                    // Handle comprehensive display option updates
                    this.socket.on('displayOptionsUpdate', (options) =>
                        this.updateDisplayOptions(options)
                    )

                    // Show live transcription text (accept string or object payloads)
                    this.socket.on('transcriptUpdate', (payload) =>
                        this.updateTranscript(payload)
                    )

                    // Handle status updates from server
                    this.socket.on('statusUpdate', (status) =>
                        this.updateStatus(status)
                    )

                    // Handle penalty detection with animations
                    this.socket.on('penaltyDetected', (penalty) =>
                        this.handlePenaltyDetected(penalty)
                    )

                    // Handle animation triggers
                    this.socket.on('animationTrigger', (animation) =>
                        this.triggerAnimation(animation.type, animation.data)
                    )

                    // Handle threshold changes
                    this.socket.on('thresholdReached', (threshold) =>
                        this.updateThreshold(threshold)
                    )

                    // Handle auto-reset triggered
                    this.socket.on('autoResetTriggered', (data) =>
                        this.handleAutoReset(data)
                    )

                    // Handle sound play events
                    this.socket.on('soundPlay', (data) =>
                        this.playSound(data.file, data.volume)
                    )
                }

                updateStatus(status) {
                    const colors = {
                        connected: '#10b981',
                        listening: '#f59e0b',
                        disconnected: '#ef4444',
                    }

                    this.setColorProperty(
                        '--status-color',
                        colors[status] || colors.disconnected
                    )
                }

                updateCounter(count) {
                    this.elements.counter.textContent = count

                    // Provide subtle visual feedback when count increases
                    this.elements.counter.style.transform =
                        'translate(-50%, -50%) scale(1.1)'
                    setTimeout(() => {
                        this.elements.counter.style.transform =
                            'translate(-50%, -50%) scale(1)'
                    }, 200)
                }

                updateTranscript(payload) {
                    if (!this.config.showTranscript) return

                    // Support legacy string payloads
                    let text = ''
                    let mode = 'immediate' // 'immediate' | 'scroll'
                    let final = false

                    if (typeof payload === 'string') {
                        text = payload
                    } else if (payload && typeof payload === 'object') {
                        // Handle payload.text possibly being non-string (defensive)
                        let t = payload.text
                        if (typeof t !== 'string') {
                            // Try to extract common transcript fields
                            if (t && typeof t === 'object') {
                                t = t.transcript || (Array.isArray(t) ? t.join(' ') : JSON.stringify(t))
                            } else {
                                t = String(t)
                            }
                        }
                        text = t || ''
                        mode = payload.mode || (text && text.length > 20 ? 'scroll' : 'immediate')
                        final = !!payload.final

                        // Debug unexpected payload shapes
                        if (!payload.text || typeof payload.text !== 'string') {
                            console.debug('transcriptUpdate received non-string payload.text, normalized to string:', payload)
                        }
                    }

                    const displayText = text || 'Listening for audio...'

                    // Reset any previous scroll animation
                    this.elements.transcript.classList.remove('scrolling')
                    this.elements.transcript.classList.remove('scroll-prep')

                    if (mode === 'scroll' && text) {
                        // Prepare text offscreen immediately to avoid centered flash
                        this.elements.transcript.classList.add('scroll-prep')
                        this.elements.transcript.textContent = displayText

                        // Force reflow so measurements are accurate
                        this.elements.transcript.offsetHeight

                        // After a short delay measure width and start scrolling if needed
                        setTimeout(() => {
                            const wrapper = this.elements.transcriptContainer.querySelector('.transcript-wrapper')
                            const containerWidth = wrapper ? wrapper.offsetWidth : this.elements.transcriptContainer.offsetWidth
                            const textWidth = this.elements.transcript.scrollWidth

                            if (textWidth > containerWidth) {
                                // Start the scrolling animation. Keep scroll-prep for positioning; animation's 0% uses translate(100%, -50%)
                                this.elements.transcript.classList.add('scrolling')

                                // Remove the prep class after a tiny delay so animation has taken effect
                                setTimeout(() => {
                                    this.elements.transcript.classList.remove('scroll-prep')
                                }, 20)
                            } else {
                                // No scrolling needed, show centered text
                                this.elements.transcript.classList.remove('scroll-prep')
                            }
                        }, 40)
                    } else {
                        // Immediate display: set centered text
                        this.elements.transcript.textContent = displayText
                    }
                }

                updateTheme(theme) {
                    if (theme.primaryColor) {
                        this.setColorProperty(
                            '--primary-color',
                            theme.primaryColor
                        )
                    }
                    if (theme.secondaryColor) {
                        this.setColorProperty(
                            '--secondary-color',
                            theme.secondaryColor
                        )
                    }
                }

                updateDisplayOptions(options) {
                    // Handle layout configuration changes
                    if (options.layout) {
                        this.config.layout = options.layout
                        this.elements.container.classList.toggle(
                            'horizontal',
                            options.layout === 'horizontal'
                        )
                    }

                    if (options.transcriptPosition) {
                        this.config.transcriptPosition =
                            options.transcriptPosition
                        this.elements.transcriptContainer.classList.toggle(
                            'above',
                            options.transcriptPosition === 'above'
                        )
                        this.elements.status.classList.toggle(
                            'transcript-above',
                            options.transcriptPosition === 'above'
                        )
                    }

                    // Configure background appearance
                    if (options.showBackground !== undefined) {
                        this.config.showBackground = options.showBackground
                        this.elements.container.classList.toggle(
                            'no-background',
                            !options.showBackground
                        )
                    }

                    if (options.backgroundColor || options.backgroundAlpha !== undefined) {
                        console.log('Updating background - color:', options.backgroundColor, 'alpha:', options.backgroundAlpha);
                        const currentBgColor = options.backgroundColor || localStorage.getItem('backgroundColor') || '#000000';
                        const currentBgAlpha = options.backgroundAlpha !== undefined ? options.backgroundAlpha : 0.8;
                        this.setColorProperty(
                            '--background-color',
                            this.hexToRgba(currentBgColor, currentBgAlpha)
                        )
                        console.log('Background updated to:', this.hexToRgba(currentBgColor, currentBgAlpha));
                    }

                    // Update status indicator settings
                    if (options.showStatus !== undefined) {
                        console.log('Processing showStatus:', options.showStatus, 'type:', typeof options.showStatus);
                        this.config.showStatus = options.showStatus
                        this.elements.status.classList.toggle(
                            'hidden',
                            !options.showStatus
                        )
                        console.log('Status indicator hidden class:', this.elements.status.classList.contains('hidden'));
                    }

                    if (options.statusColor) {
                        this.setColorProperty(
                            '--status-color',
                            options.statusColor
                        )
                    }

                    if (options.statusAlpha !== undefined) {
                        this.setProperty('--status-alpha', options.statusAlpha)
                    }

                    // Configure trash bin appearance
                    if (options.binColor) {
                        console.log('Updating bin color to:', options.binColor);
                        console.log('Current --bin-color value:', getComputedStyle(document.documentElement).getPropertyValue('--bin-color'));
                        this.setColorProperty('--bin-color', options.binColor)
                        console.log('New --bin-color value:', getComputedStyle(document.documentElement).getPropertyValue('--bin-color'));
                    }

                    if (options.binAlpha !== undefined) {
                        this.setProperty('--bin-alpha', options.binAlpha)
                    }

                    if (options.binSize) {
                        console.log('Setting bin size to:', options.binSize + 'px')
                        this.setProperty('--bin-size', options.binSize + 'px')
                    }

                    // Update counter display settings
                    if (options.counterColor) {
                        this.setColorProperty(
                            '--counter-color',
                            options.counterColor
                        )
                    }

                    if (options.counterAlpha !== undefined) {
                        this.setProperty(
                            '--counter-alpha',
                            options.counterAlpha
                        )
                    }

                    // Configure transcript display
                    if (options.showTranscript !== undefined) {
                        console.log('Processing showTranscript:', options.showTranscript, 'type:', typeof options.showTranscript);
                        this.config.showTranscript = options.showTranscript
                        this.elements.transcriptContainer.classList.toggle(
                            'hidden',
                            !options.showTranscript
                        )
                        console.log('Transcript container hidden class:', this.elements.transcriptContainer.classList.contains('hidden'));
                    }

                    if (options.transcriptColor) {
                        this.setColorProperty(
                            '--transcript-color',
                            options.transcriptColor
                        )
                    }

                    if (options.transcriptAlpha !== undefined) {
                        this.setProperty(
                            '--transcript-alpha',
                            options.transcriptAlpha
                        )
                    }

                    // Update threshold settings
                    if (options.enableThresholds !== undefined) {
                        console.log('Updating enableThresholds setting to:', options.enableThresholds);
                        localStorage.setItem('enableThresholds', options.enableThresholds);

                        // If thresholds are being disabled, remove any existing threshold classes
                        if (!options.enableThresholds) {
                            console.log('Thresholds disabled - removing threshold classes');
                            const binContainer = document.querySelector('.trash-bin-container');
                            const bin = document.querySelector('.trash-bin');
                            const counter = document.querySelector('.counter');

                            if (binContainer && bin && counter) {
                                binContainer.classList.remove('threshold-warning', 'threshold-danger');
                                bin.classList.remove('threshold-warning', 'threshold-danger');
                                counter.classList.remove('threshold-warning', 'threshold-danger');
                            }
                        }
                    }
                }

                applyDefaultTheme() {
                    this.setColorProperty('--primary-color', '#6366f1')
                    this.setColorProperty('--secondary-color', '#f472b6')
                }

                loadSavedSettings() {
                    // Load all saved display settings from localStorage
                    console.log('Loading saved settings from localStorage...');
                    console.log('binColor from localStorage:', localStorage.getItem('binColor'));
                    console.log('showStatus from localStorage:', localStorage.getItem('showStatus'));
                    console.log('showTranscript from localStorage:', localStorage.getItem('showTranscript'));
                    console.log('enableThresholds from localStorage:', localStorage.getItem('enableThresholds'));
                    const savedSettings = {
                        layout: localStorage.getItem('layoutMode') || 'vertical',
                        transcriptPosition: localStorage.getItem('transcriptPosition') || 'below',
                        showBackground: localStorage.getItem('showBackground') !== 'false',
                        backgroundColor: localStorage.getItem('backgroundColor') || '#000000',
                        backgroundAlpha: parseFloat(localStorage.getItem('backgroundAlpha')) || 0.8,
                        binColor: localStorage.getItem('binColor') || '#ffffff',
                        binAlpha: parseFloat(localStorage.getItem('binAlpha')) || 1,
                        binSize: parseInt(localStorage.getItem('binSize')) || 80,
                        counterColor: localStorage.getItem('counterColor') || '#000000',
                        counterAlpha: parseFloat(localStorage.getItem('counterAlpha')) || 1,
                        showStatus: localStorage.getItem('showStatus') !== 'false',
                        statusColor: localStorage.getItem('statusColor') || '#10b981',
                        statusAlpha: parseFloat(localStorage.getItem('statusAlpha')) || 1,
                        statusSize: parseInt(localStorage.getItem('statusSize')) || 12,
                        showTranscript: localStorage.getItem('showTranscript') !== 'false',
                        transcriptColor: localStorage.getItem('transcriptColor') || '#ffffff',
                        transcriptAlpha: parseFloat(localStorage.getItem('transcriptAlpha')) || 0.9,
                        enableThresholds: localStorage.getItem('enableThresholds') !== 'false'
                    }

                    console.log('Loading saved settings:', savedSettings)

                    // Apply the loaded settings
                    this.updateDisplayOptions(savedSettings)
                }

                setProperty(property, value) {
                    document.documentElement.style.setProperty(property, value)
                }

                setColorProperty(property, color) {
                    if (color.startsWith('#')) {
                        this.setProperty(property, color)
                    } else if (color.startsWith('rgb')) {
                        this.setProperty(property, color)
                    } else {
                        this.setProperty(property, color)
                    }
                }

                hexToRgba(hex, alpha = 1) {
                    if (!hex) return null

                    // Remove hash prefix and expand shorthand hex colors
                    hex = hex.replace('#', '')
                    if (hex.length === 3) {
                        hex = hex
                            .split('')
                            .map((c) => c + c)
                            .join('')
                    }

                    // Convert hex components to RGB values
                    const r = parseInt(hex.substring(0, 2), 16)
                    const g = parseInt(hex.substring(2, 4), 16)
                    const b = parseInt(hex.substring(4, 6), 16)
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`
                }

                // Animation and threshold handling methods
                handlePenaltyDetected(penalty) {
                    console.log('Penalty detected:', penalty)

                    // Trigger appropriate animation based on penalty source
                    if (penalty.source === 'mic') {
                        this.triggerAnimation('binShake', { intensity: 5 })
                    } else if (penalty.source === 'chat') {
                        this.triggerAnimation('lidTip', { duration: 800 })
                    }
                }

                triggerAnimation(type, data = {}) {
                    const binContainer = document.querySelector('.trash-bin-container')
                    if (!binContainer) return

                    // Remove any existing animation classes
                    binContainer.classList.remove('shaking', 'lid-tip')

                    // Add appropriate animation class
                    if (type === 'binShake') {
                        binContainer.classList.add('shaking')

                        // Remove class after animation completes
                        setTimeout(() => {
                            binContainer.classList.remove('shaking')
                        }, 600)

                    } else if (type === 'lidTip') {
                        binContainer.classList.add('lid-tip')

                        // Remove class after animation completes
                        setTimeout(() => {
                            binContainer.classList.remove('lid-tip')
                        }, 800)
                    }

                    console.log(`Animation triggered: ${type}`, data)
                }

                updateThreshold(threshold) {
                    // Check if thresholds are enabled (from localStorage or config)
                    const thresholdsEnabled = localStorage.getItem('enableThresholds')
                    console.log('Threshold triggered - enableThresholds setting:', thresholdsEnabled)
                    if (thresholdsEnabled === 'false') {
                        console.log('Thresholds disabled, keeping base bin color')
                        return
                    }

                    const binContainer = document.querySelector('.trash-bin-container')
                    const bin = document.querySelector('.trash-bin')
                    const counter = document.querySelector('.counter')

                    if (!binContainer || !bin || !counter) return

                    // Remove existing threshold classes
                    binContainer.classList.remove('threshold-warning', 'threshold-danger')
                    bin.classList.remove('threshold-warning', 'threshold-danger')
                    counter.classList.remove('threshold-warning', 'threshold-danger')

                    // Apply new threshold styling
                    if (threshold.name.toLowerCase() === 'warning') {
                        binContainer.classList.add('threshold-warning')
                        bin.classList.add('threshold-warning')
                        counter.classList.add('threshold-warning')

                        // Set warning color
                        this.setColorProperty('--warning-color', threshold.color)

                    } else if (threshold.name.toLowerCase() === 'danger') {
                        binContainer.classList.add('threshold-danger')
                        bin.classList.add('threshold-danger')
                        counter.classList.add('threshold-danger')

                        // Set danger color
                        this.setColorProperty('--danger-color', threshold.color)
                    }

                    console.log('Threshold updated:', threshold)
                }

                handleAutoReset(data) {
                    console.log('Auto-reset triggered:', data)

                    // Trigger a special reset animation
                    this.triggerAnimation('reset', { resetTime: data.resetTime })

                    // Flash the background briefly to indicate reset
                    const container = document.querySelector('.overlay-container')
                    if (container) {
                        container.style.background = 'rgba(16, 185, 129, 0.3)'
                        setTimeout(() => {
                            container.style.background = 'var(--background-color)'
                        }, 1000)
                    }

                    // Reset all threshold classes
                    const binContainer = document.querySelector('.trash-bin-container')
                    const bin = document.querySelector('.trash-bin')
                    const counter = document.querySelector('.counter')

                    if (binContainer && bin && counter) {
                        binContainer.classList.remove('threshold-warning', 'threshold-danger')
                        bin.classList.remove('threshold-warning', 'threshold-danger')
                        counter.classList.remove('threshold-warning', 'threshold-danger')
                    }
                }

                playSound(file, volume = 0.5) {
                    try {
                        const audio = new Audio(file)
                        audio.volume = Math.max(0, Math.min(1, volume))
                        audio.play().catch(error => {
                            console.warn('Failed to play sound:', error)
                        })
                        console.log(`Playing sound: ${file} at volume ${Math.round(volume * 100)}%`)
                    } catch (error) {
                        console.error('Error creating audio element:', error)
                    }
                }
            }

            // Initialize overlay when DOM is ready
            document.addEventListener('DOMContentLoaded', () => {
                new MinimalOverlay()
            })
        </script>
    </body>
</html>
